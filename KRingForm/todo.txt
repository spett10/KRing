1. Make App.config point to different files dependent on build (debug vs release) http://stackoverflow.com/questions/3004210/app-config-transformation-for-projects-which-are-not-web-projects-in-visual-stud
2. Config datapoint - Enable you to point to a folder that is the storage - this way, you can put the folder in dropbox, and have 2 computers point to the same data folder, its synced automatically, not dangerous since everything is encrypted. Brilliant
	-save the path in a config, alter it at runtime. 
	-do it under a setting button in the main view 
3. Make textboxes listen to keystrokes instead of copying the plaintextpassword which is obfuscated with **** in gui. Listen for events and inspect keystrokes?
4. consider having a k1 that is derived from user password and salt (update for each time?). Then, use that to encrypt/decrypt the symmetric key used for encrypting the passwords.
Then we can change password for the user, but not need to change the key used for encrypting all the entries, so we dont need to reencrypt. 
5. Should we derive a masterkey, then derive the two needed keys from that key? I think that is better practice.
6. Make an icon for the buld thingie.
7. Integration / automated UI tests with AutoIT scripting?
8: Import functionality for everything. Point to a folder to "load". If it has the correct structure and format, overwrite current stored stuff with what we read. 
Require master password to confirm? 
9. import functionality just for passwords (not the rest). Support diff formats (plaintext done, encrypted, json structures etc)
10 export functionality to some different formats as well? The same that we can import? 
11. backup functionality. or export or something. copy data and import data so we dont have to copy paste.
	-export to a zip? Not needed. Just export to a folder. And import a folder. If files are not called what they should, then abort. Then its easier to update.
	Require password when reloading? 
12. folder structures for the main view in passwordlist
14. Add more tests to new functionalities such as plaintextpasswordimporter, ReadToEndStoredPasswordRepository etc.
15. the passwordlist form is dragabble. whether or not it should be, the buttons etc do not follow.
	perhaps increase the base size? In general the ux is very limited. 
16. Add a message counter to all lines written to the underlying format (i.e. to the encrypted message? after some delimiter).
	As it is know, people could swap elements around, and since the encryption key is the same for all elements per save, and the same for the mac key,
	an attacker could swap elements to make it appear as though keys should be in a certain order when they shold not be .
	we can reuse the import tool for migration. 
17. Find a higher number of iterations for key derivation. See what effects it has on the ui - switch to async methods if it does not help? 
	Otherwise add a loading bar or something. 
		-How do we migrate users for this? If we set the iteration higher, authentication will fail. They would have to make a new user, and import all over again... 
		-So a prerequisite would be to enable delete user functionality. 

		-Or in a transition period, have it try a series of values in a dictionary, and then update afterwards with the highest one? Then patch that out afterwards.. 
			-Put into config - last used and new used iteration count. Then populate these fields at startup, and use accordingly. 

		-Make the config permanent, so once can always update the "new higehst" along the way and be safe. 
18. Use new key derivation algorithm we got from bouncy castle. How do we migrate? Guess we import. Then make export functionality. Can we encrypt and decrypt the exported stuff using a one time password sort of deal? So its less stupid? Then we could export,
delete user, create again, then import. 
19. We need some solution for enabling upscaling of parameters in future... That does not require manual migration. 
20. How to add 2factor? Email? Sms? but how to authenticate that what we get is good? Send a challenge or something, how do others do it? could be cool

21. Encrypt config? i think its possible easily in .net, not sure about windows forms. 

Can some of the above problems be solved by simply wiriting the different algorithms in the data we store? 
similar to JWKS. then we know what algorithm and parameters where used, and we can use that. 
But how can that help transition? If we write in the data format what key derivation algorithm and iteration that was used? How do we authenticate that though? guess we cant.. an attacker can set
the hashing iteration to be something like.. 1. and then generate a lot of hashes really fast. then he could log in, but not decrypt, since the generated symmetric key would not be valid since the iteration count was altered.
still seems sketchy as fuck. 

Todo: 
1) make the count of iterations configurable. hardcode the algoritm. We have to transatition anyways, trying both algs is too much work
2) Make an export functionality so its easier to transition - export encrypted under a key. then an import for the same format that decrypts. 
3) export, then build the new stuff with the new algorithm for both authentication and key derivation, import the xported stuff, save, you are good to go. 

when we have export import in a secure manner, the rest should be fine? Just always keep export import fixed with regards to parameters,
then the rest can change as it wants to. It should be independant at least. 

BUGS:


links:
Read more about PBKDF2 here: TLDR: its not wrong what we do, but its not great either. 
	https://security.stackexchange.com/questions/53115/how-to-know-which-output-length-to-request-from-pbkdf2
		https://www.lastpass.com/how-it-works used the above + aes256, so we should aim for the same
			-bouncy castle has PBEwithHmacSHA-256 and others: http://www.bouncycastle.org/csharp/
good discussion about masterpassword usage (which KRing essentially is, if anyone knows your master password, all bets are off )https://security.stackexchange.com/questions/48174/if-i-use-a-good-master-password-in-firefox-is-security-improved-when-i-remember