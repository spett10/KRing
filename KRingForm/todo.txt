1. password rules are dumb. passphrases are currently not quite possible? i also think we can amp up the input to more than 80 (not unlimited due to ddos attacks but still more than currently).
i think just the length should be checked?
3. Make textboxes listen to keystrokes instead of copying the plaintextpassword which is obfuscated with **** in gui. Listen for events and inspect keystrokes?
4. consider having a k1 that is derived from user password and salt (update for each time?). Then, use that to encrypt/decrypt the symmetric key used for encrypting the passwords.
Then we can change password for the user, but not need to change the key used for encrypting all the entries, so we dont need to reencrypt. 
5. Should we derive a masterkey, then derive the two needed keys from that key? I think that is better practice.
6. Make an icon for the buld thingie.
7. Integration / automated UI tests with AutoIT scripting?
12. folder structures for the main view in passwordlist
14. Add more tests to new functionalities such as plaintextpasswordimporter, ReadToEndStoredPasswordRepository etc.
15. the passwordlist form is dragabble. whether or not it should be, the buttons etc do not follow.
	perhaps increase the base size? In general the ux is very limited. 
16. Add a message counter to all lines written to the underlying format (i.e. to the encrypted message? after some delimiter).
	As it is know, people could swap elements around, and since the encryption key is the same for all elements per save, and the same for the mac key,
	an attacker could swap elements to make it appear as though keys should be in a certain order when they shold not be .
	we can reuse the import tool for migration. 
19. We need some solution for enabling upscaling of parameters in future... That does not require manual migration. 
20. How to add 2factor? Email? Sms? but how to authenticate that what we get is good? Send a challenge or something, how do others do it? could be cool

Can some of the above problems be solved by simply wiriting the different algorithms in the data we store? 
similar to JWKS. then we know what algorithm and parameters where used, and we can use that. 
But how can that help transition? If we write in the data format what key derivation algorithm and iteration that was used? How do we authenticate that though? guess we cant.. an attacker can set
the hashing iteration to be something like.. 1. and then generate a lot of hashes really fast. then he could log in, but not decrypt, since the generated symmetric key would not be valid since the iteration count was altered.
still seems sketchy as fuck. 

22. Maybe before we close, make a mac on the log and store at the end, then check at startup, delete log if not valid? 
23. make custom .net control that is a textbox that returns a securestring, not plaintext. listen to keystrokes, add to securestring one by one? PasswordBox exists for WPF, but not for windows forms apparently, and we cant use it here. 
24. clean up service stuff, some of it belongs in persistence (file io)
25. search should use contains instead of startwith
26. edit should be called update or it should show the old password so yo ucan catually edit it? 
27. make a key check value as described in cryptographic engineering chapter 21. That is, a vlaue that is mac'd with the dervied key. Then check this value
when user logs in and the key is derived, and only if it checks out, should you attempt to decrypt and check tag of remaning stored vlaues (passwords).
This saves time on wrong logons and such. Should depend on salt somehow, so it is updated after each reencryption, such that it is not too 
open to dictionary attacks. but not ONLY on the salt for gods sake, then its a true dictionary attack enabler. It should be a mac on something the attacker doesnt know,
like the password, so it could be a mac on sha256( something? || password || salt ). Then an attacker cant dictionary attack it, since you pnly store the mac value,
not the data for the mach - that is derived at runtime and depends on password, so the attacker cant do offline dictionary attacks. the only thing we store is salt (something should be dervierd
at runtime)
28. figure out what iterations should be on key derivation experimentally - 1000 ms should be acceptable for the user to wait for. 

30. We need logic for trying both old and new value for key derivation? Since we only do it for auth right now, and that might work,
but the key derivation at runtime for crypto does not try the old one, so the authentication stuff is pointless.
The key check in 27 could be used for this, to test both iterations, and then finding out which iteration to use.
But... This would stil require an update of the program on someones computer, meaning the user has to import and export anyways? and at that point,
you could just update the numbers directly, since the user has to take the new executable. sure, they could log in using their old data, but that is only for the profile,
so creating a new user instead would mean you dont have to copy the profile data around (MANUALLY I MIGHT ADD!), then it might be actually more friendly to start
over with new (same) user and password, then import the passwords? then there is no manual action outside the program. Then there would need to be an export for the profile for this to work.

30.5: amp up them iterations, then release so you get better version already. Need loading screens to make more user friendly - and use the async stuff where appropraite? even in program perhaps,
the constructors might call non-async thingies i suspect.. move that to seperate load calls that are async so ui doesnt freeze. 

31. we should derive a new key each time, not just new salt.
this gives forward secrecy. as it is now, the same key is always derived at runtime. 
if we get fresh salt for key derivation each time, then we get a different set of keys each run of the program,
so if a key gets leaked once, then its not gonna be valid for ever, only for that one run of the program, so
kind of forward secrecy. leaking of master password is still fatal of course. 
	-should we always reencrypt? the problem is that if we also do it on form closing, then if the user changed something, didnt save the changes yet (cos he not sure),
	then if he doenst save and wants to exit, then we should not force reencrypt? But then attacker can distinguish between when someone changes password and they dont.
	but they can still see the length though.. how to avoid that? then we would always have to pad and stuff... 

	todo: keep two lists in password list (show their concat), respecitvely the passwords we loaded, and those we changed. somehow merge? discard the new ones if we dont save, then reencrypt old ones..?


32. add option for 32 lenght password, perhaps even more. if its random and generated and remembred by the program, go large man! no reason to stop at 16, maybe go higher than 64? 

Export/Import
	-the tag created for export should be a tag on the fields in the exported format, not just the cipher text itself? mac what you mean and all that. 

ORAM:
instead of decrypting when loading all passwordsi nto memory, have them encrypted in memory and construct an ORAM? 

BUGS:

INSECURITIES:
The authentication to log on simply reads the data folder that has the hashed password. Any attacker can substitute
the values stored here for hashes produced by the same algorithms and parameters, but with a password he knows.
That would allow an attacker to "log in" - but this would be of little use, since his password would not be the correct one,
that the actual user used. This means the key derviation at runtime for encryption and macs would not be correct,
so he would not be able to decrypt correctly, so he would gain no information. However, its still not a good design. Can we
make this data internal? 


LINKS:
Read more about PBKDF2 here: TLDR: its not wrong what we do, but its not great either. 
	https://security.stackexchange.com/questions/53115/how-to-know-which-output-length-to-request-from-pbkdf2
		https://www.lastpass.com/how-it-works used the above + aes256, so we should aim for the same
			-bouncy castle has PBEwithHmacSHA-256 and others: http://www.bouncycastle.org/csharp/
good discussion about masterpassword usage (which KRing essentially is, if anyone knows your master password, all bets are off )https://security.stackexchange.com/questions/48174/if-i-use-a-good-master-password-in-firefox-is-security-improved-when-i-remember