
1. make the needed files be embedded resources instead of just files? 

3. Make textboxes listen to keystrokes instead of copying the plaintextpassword which is obfuscated with **** in gui. Listen for events and inspect keystrokes?
4. consider having a k1 that is derived from user password and salt (update for each time?). Then, use that to encrypt/decrypt the symmetric key used for encrypting the passwords.
Then we can change password for the user, but not need to change the key used for encrypting all the entries, so we dont need to reencrypt. 
5. Should we derive a masterkey, then derive the two needed keys from that key? I think that is better practice.
6. Make an icon for the buld thingie.
7. Integration / automated UI tests with AutoIT scripting? that sounds fun... but kinda needed. the manual testing when there are so many buttons is just ass
12. folder structures for the main view in passwordlist
14. Add more tests to new functionalities such as plaintextpasswordimporter, ReadToEndStoredPasswordRepository etc.
16. Add a message counter to all lines written to the underlying format (i.e. to the encrypted message? after some delimiter).
	As it is know, people could swap elements around, and since the encryption key is the same for all elements per save, and the same for the mac key,
	an attacker could swap elements to make it appear as though keys should be in a certain order when they shold not be .
	we can reuse the import tool for migration. 
19. We need some solution for enabling upscaling of parameters in future... That does not require manual migration. 
20. How to add 2factor? Email? Sms? but how to authenticate that what we get is good? Send a challenge or something, how do others do it? could be cool

Can some of the above problems be solved by simply wiriting the different algorithms in the data we store? 
similar to JWKS. then we know what algorithm and parameters where used, and we can use that. 
But how can that help transition? If we write in the data format what key derivation algorithm and iteration that was used? How do we authenticate that though? guess we cant.. an attacker can set
the hashing iteration to be something like.. 1. and then generate a lot of hashes really fast. then he could log in, but not decrypt, since the generated symmetric key would not be valid since the iteration count was altered.
still seems sketchy as fuck. 

22. Maybe before we close, make a mac on the log and store at the end, then check at startup, delete log if not valid? people cant fake mac if its based on user password. 
23. make custom .net control that is a textbox that returns a securestring, not plaintext. listen to keystrokes, add to securestring one by one? PasswordBox exists for WPF, but not for windows forms apparently, and we cant use it here. 
24. clean up service stuff, some of it belongs in persistence (file io)
26. edit should be called update or it should show the old password so yo ucan catually edit it? 
27. make a key check value as described in cryptographic engineering chapter 21. That is, a vlaue that is mac'd with the dervied key. Then check this value
when user logs in and the key is derived, and only if it checks out, should you attempt to decrypt and check tag of remaning stored vlaues (passwords).
This saves time on wrong logons and such. Should depend on salt somehow, so it is updated after each reencryption, such that it is not too 
open to dictionary attacks. but not ONLY on the salt for gods sake, then its a true dictionary attack enabler. It should be a mac on something the attacker doesnt know,
like the password, so it could be a mac on sha256( something? || password || salt ). Then an attacker cant dictionary attack it, since you pnly store the mac value,
not the data for the mach - that is derived at runtime and depends on password, so the attacker cant do offline dictionary attacks. the only thing we store is salt (something should be dervierd
at runtime)

30. We need logic for trying both old and new value for key derivation? Since we only do it for auth right now, and that might work,
but the key derivation at runtime for crypto does not try the old one, so the authentication stuff is pointless.
The key check in 27 could be used for this, to test both iterations, and then finding out which iteration to use.
But... This would stil require an update of the program on someones computer, meaning the user has to import and export anyways? and at that point,
you could just update the numbers directly, since the user has to take the new executable. sure, they could log in using their old data, but that is only for the profile,
so creating a new user instead would mean you dont have to copy the profile data around (MANUALLY I MIGHT ADD!), then it might be actually more friendly to start
over with new (same) user and password, then import the passwords? then there is no manual action outside the program. Then there would need to be an export for the profile for this to work.


31- use password importer / exporter for the DB part? right now the individual lines in the DB kinda leak the length of the passwords to some extend. Harder to see such things
if we just reencrypt an entire blob instead? 


Export/Import
	-the tag created for export should be a tag on the fields in the exported format, not just the cipher text itself? mac what you mean and all that. 
		start with export doing it, then save the exported stuff, then fix the import afterwards. 
		then you can go release -> export, then implement the import, then release, try importing the export. then you dont loose passwords. 

ORAM:
instead of decrypting when loading all passwordsi nto memory, have them encrypted in memory and construct an ORAM? 

BUGS:



INSECURITIES:
The authentication to log on simply reads the data folder that has the hashed password. Any attacker can substitute
the values stored here for hashes produced by the same algorithms and parameters, but with a password he knows.
That would allow an attacker to "log in" - but this would be of little use, since his password would not be the correct one,
that the actual user used. This means the key derviation at runtime for encryption and macs would not be correct,
so he would not be able to decrypt correctly, so he would gain no information. However, its still not a good design. Can we
make this data internal? 


LINKS:
Read more about PBKDF2 here:
	https://security.stackexchange.com/questions/53115/how-to-know-which-output-length-to-request-from-pbkdf2
		https://www.lastpass.com/how-it-works used the above + aes256, so we should aim for the same
			-bouncy castle has PBEwithHmacSHA-256 and others: http://www.bouncycastle.org/csharp/
good discussion about masterpassword usage (which KRing essentially is, if anyone knows your master password, all bets are off )https://security.stackexchange.com/questions/48174/if-i-use-a-good-master-password-in-firefox-is-security-improved-when-i-remember