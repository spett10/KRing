1. Make App.config point to different files dependent on build (debug vs release) http://stackoverflow.com/questions/3004210/app-config-transformation-for-projects-which-are-not-web-projects-in-visual-stud
2. Config datapoint - Enable you to point to a folder that is the storage - this way, you can put the folder in dropbox, and have 2 computers point to the same data folder, its synced automatically, not dangerous since everything is encrypted. Brilliant
	-save the path in a config, alter it at runtime. 
	-do it under a setting button in the main view 
3. Make textboxes listen to keystrokes instead of copying the plaintextpassword which is obfuscated with **** in gui. Listen for events and inspect keystrokes?
4. consider having a k1 that is derived from user password and salt (update for each time?). Then, use that to encrypt/decrypt the symmetric key used for encrypting the passwords.
Then we can change password for the user, but not need to change the key used for encrypting all the entries, so we dont need to reencrypt. 
5. Should we derive a masterkey, then derive the two needed keys from that key? I think that is better practice.
6. Make an icon for the buld thingie.
7. Integration / automated UI tests with AutoIT scripting?
12. folder structures for the main view in passwordlist
14. Add more tests to new functionalities such as plaintextpasswordimporter, ReadToEndStoredPasswordRepository etc.
15. the passwordlist form is dragabble. whether or not it should be, the buttons etc do not follow.
	perhaps increase the base size? In general the ux is very limited. 
16. Add a message counter to all lines written to the underlying format (i.e. to the encrypted message? after some delimiter).
	As it is know, people could swap elements around, and since the encryption key is the same for all elements per save, and the same for the mac key,
	an attacker could swap elements to make it appear as though keys should be in a certain order when they shold not be .
	we can reuse the import tool for migration. 
19. We need some solution for enabling upscaling of parameters in future... That does not require manual migration. 
20. How to add 2factor? Email? Sms? but how to authenticate that what we get is good? Send a challenge or something, how do others do it? could be cool

Can some of the above problems be solved by simply wiriting the different algorithms in the data we store? 
similar to JWKS. then we know what algorithm and parameters where used, and we can use that. 
But how can that help transition? If we write in the data format what key derivation algorithm and iteration that was used? How do we authenticate that though? guess we cant.. an attacker can set
the hashing iteration to be something like.. 1. and then generate a lot of hashes really fast. then he could log in, but not decrypt, since the generated symmetric key would not be valid since the iteration count was altered.
still seems sketchy as fuck. 

22. Make the activity thingie a singleton that has a notify call instead of passing it to every single form. 
23. make custom .net control that is a textbox that returns a securestring, not plaintext. listen to keystrokes, add to securestring one by one? PasswordBox exists for WPF, but not for windows forms apparently, and we cant use it here. 
24. clean up service stuff, some of it belongs in persistence (file io)

Export/Import
	-the tag created for export should be a tag on the fields in the exported format, not just the cipher text itself? mac what you mean and all that. 

BUGS:

INSECURITIES:
The authentication to log on simply reads the data folder that has the hashed password. Any attacker can substitute
the values stored here for hashes produced by the same algorithms and parameters, but with a password he knows.
That would allow an attacker to "log in" - but this would be of little use, since his password would not be the correct one,
that the actual user used. This means the key derviation at runtime for encryption and macs would not be correct,
so he would not be able to decrypt correctly, so he would gain no information. However, its still not a good design. Can we
make this data internal? 


LINKS:
Read more about PBKDF2 here: TLDR: its not wrong what we do, but its not great either. 
	https://security.stackexchange.com/questions/53115/how-to-know-which-output-length-to-request-from-pbkdf2
		https://www.lastpass.com/how-it-works used the above + aes256, so we should aim for the same
			-bouncy castle has PBEwithHmacSHA-256 and others: http://www.bouncycastle.org/csharp/
good discussion about masterpassword usage (which KRing essentially is, if anyone knows your master password, all bets are off )https://security.stackexchange.com/questions/48174/if-i-use-a-good-master-password-in-firefox-is-security-improved-when-i-remember